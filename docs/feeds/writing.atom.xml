<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dan Puttick - writing</title><link href="https://www.danielputtick.com/" rel="alternate"></link><link href="https://www.danielputtick.com/feeds/writing.atom.xml" rel="self"></link><id>https://www.danielputtick.com/</id><updated>2017-07-17T19:22:00-04:00</updated><entry><title>Understanding subnet masks</title><link href="https://www.danielputtick.com/writing/subnet-masks.html" rel="alternate"></link><published>2017-07-17T18:00:00-04:00</published><updated>2017-07-17T19:22:00-04:00</updated><author><name>Dan Puttick</name></author><id>tag:www.danielputtick.com,2017-07-17:/writing/subnet-masks.html</id><summary type="html">&lt;p&gt;I have a fairly broad understanding of networking and how the Internet works. However, for some reason, I had previously never fully understood exactly what a subnet mask is. Why are &lt;span class="caps"&gt;IP&lt;/span&gt; addresses sometimes written with a slash and another number (10.0.0.1/24) at the end of …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I have a fairly broad understanding of networking and how the Internet works. However, for some reason, I had previously never fully understood exactly what a subnet mask is. Why are &lt;span class="caps"&gt;IP&lt;/span&gt; addresses sometimes written with a slash and another number (10.0.0.1/24) at the end of them? Why do you see something like ”subnet mask: 255.255.255.0” in your network configuration settings? I knew that both had something to do with subnet masks, but not much beyond that. To learn more, I decided to jot down some notes on the subject. This post assumes some basic understanding of &lt;span class="caps"&gt;IP&lt;/span&gt; addressing and the Internet, although I’ll try to fill in as much detail as I can. It turns out that, to properly understand subnet masks and the context for their existence, you need to learn a surprising amount about the architecture and evolution of the&amp;nbsp;Internet.&lt;/p&gt;
&lt;div class="section" id="the-ip-addressing-system"&gt;
&lt;h2&gt;The &lt;span class="caps"&gt;IP&lt;/span&gt; addressing&amp;nbsp;system&lt;/h2&gt;
&lt;p&gt;First, the &lt;span class="caps"&gt;IP&lt;/span&gt; (internet protocol) addressing system. &lt;span class="caps"&gt;IP&lt;/span&gt; addresses are a solution to a core design problem that arises when sending messages across any type of network: how do you efficiently ensure that every message arrives at the correct destination? To solve this problem in the real world, many countries use a system of physical street addresses. Everybody puts their street number above their door, and the government assigns and keeps track of street names (fortunately, those don’t change often). The organizational structure of the Post Office then ensures that every letter makes it to the right mailbox. Within that structure, each individual Post Office location independently applies a set of rules for sorting and passing on letters and packages. By independently, I mean that they don’t consult some central authority for instructions each time a letter is dropped off. Although there are similarities, the &lt;span class="caps"&gt;IP&lt;/span&gt; system looks a little different than the post office, largely because solving the addressing problem on the Internet is more difficult. The number of clients is an order of magnitude larger, intermediate routers are controlled by many different entities, computers connect and disconnect to the Internet much more frequently than people change their street addresses, and the volume of messages and speed of handling them is significantly&amp;nbsp;greater.&lt;/p&gt;
&lt;p&gt;IPv4, the first “production” version of &lt;span class="caps"&gt;IP&lt;/span&gt; addressing, was initially described together with &lt;span class="caps"&gt;TCP&lt;/span&gt; in a &lt;a class="reference external" href="https://www.cs.princeton.edu/courses/archive/fall06/cos561/papers/cerf74.pdf"&gt;1974 paper&lt;/a&gt; and deployed on the Internet predecessor &lt;span class="caps"&gt;ARPANET&lt;/span&gt; in 1983. Each IPv4 address is a series of 4 bytes (thus 32 bits). This means that, despite any appearances to the contrary, an &lt;span class="caps"&gt;IP&lt;/span&gt; address is just an integer with a value between 0 and 2&lt;sup&gt;32&lt;/sup&gt; – the typical “dotted quad” notation’s purpose is to make an address easily human readable. But, assigning a unique identifier to every device on the Internet isn’t sufficient to solve the message routing problem! The network needs some sort of overall structure or “topology”, otherwise designing a system of &lt;em&gt;efficiently&lt;/em&gt; routing messages becomes quite difficult. Going back to our mail analogy, imagine if the Post Office had to deliver mail by looking up every address in a giant atlas or table, rather than relying on the fact that each &lt;span class="caps"&gt;ZIP&lt;/span&gt; code consists of a contiguous area. Maintaining that atlas would be an enormous amount of work, and looking up each address would take a long time. And of course, with the Internet, computers join and leave the network very frequently, so the “atlas” would be constantly out of&amp;nbsp;date.&lt;/p&gt;
&lt;p&gt;To create this organization, &lt;span class="caps"&gt;IP&lt;/span&gt; addresses needed to be assigned to users in an systematic way that reflected the network architecture, rather than at random. Initially, continuous ranges of &lt;span class="caps"&gt;IP&lt;/span&gt; addresses, referred to as “blocks”, were assigned to participating institutions such as Universities. The institution associated with a given &lt;span class="caps"&gt;IP&lt;/span&gt; was identified by the first byte, known as the “network byte”. For example, &lt;span class="caps"&gt;MIT&lt;/span&gt; was given the block of addresses starting with decimal 18 (18.0.0.0 through 18.255.255.255). This arrangement made the logic for routing messages straightforward. Every packet with a destination address starting with “18” could be relayed in the direction of &lt;span class="caps"&gt;MIT&lt;/span&gt;’s network. &lt;span class="caps"&gt;MIT&lt;/span&gt; would assign each machine on their internal network its own unique address using the last three bytes, known as the “host bytes”, and route the packets accordingly. Unfortunately, this system only allowed for 255 blocks of addresses, which was soon revealed to be insufficient. Since many institutions didn’t need a whole block (~16.8 million) of addresses, the system by which addresses were assigned was amended to allow three different sizes of blocks. Class A blocks were like the one given to &lt;span class="caps"&gt;MIT&lt;/span&gt; (1 network byte, 3 host bytes), Class B blocks had 2 network bytes and 2 host bytes, and Class C blocks had 3 network bytes and 1 host byte. Suddenly, there were enough blocks of addresses to accomodate many more&amp;nbsp;institutions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="classless-interdomain-routing"&gt;
&lt;h2&gt;Classless Interdomain&amp;nbsp;Routing&lt;/h2&gt;
&lt;p&gt;This arrangement worked for most of the 1980s, but problems began to emerge. One such issue: in order to know where to send packets, routers maintain what are known as routing tables. These tables are updated dynamically by routers communicating with each other using specialized protocols separate from &lt;span class="caps"&gt;TCP&lt;/span&gt;/&lt;span class="caps"&gt;IP&lt;/span&gt;. Routing tables specify information like “if you see a packet destined for an address starting with “18”, send it to this address next.” Presumably, this address, often referred to as the next “hop”, is part of the shortest path to the &lt;span class="caps"&gt;MIT&lt;/span&gt; network. With the introduction of classful block assignment, the number of sub-networks connected to the Internet grew rapidly, and the size of routing tables grew proportionally as a result. The storage requirements for these tables threatened to overwhelm the capacity of router hardware at the&amp;nbsp;time.&lt;/p&gt;
&lt;p&gt;A solution to this problem, known as &lt;span class="caps"&gt;CIDR&lt;/span&gt; (Classless Interdomain Routing), was released in 1993. It’s important to mention again that there is no inherent difference between the network and host portion of an &lt;span class="caps"&gt;IP&lt;/span&gt; address – as I mentioned, an &lt;span class="caps"&gt;IP&lt;/span&gt; address is just a group of 32 bits. The dividing line between the network and host sections is always “in the eye of the beholder”. With classful routing, this dividing line was always located in the same place, depending solely on the class of the destination network. As a result, every router on the internet had the same key for that network in their routing table. In contrast, &lt;span class="caps"&gt;CIDR&lt;/span&gt; allows routers to maintain a flexible distinction between the host and network bytes. How does that work? Let’s say a router receives a packet destined for address 123.123.123.123, which happens to be somewhere “far away” (requiring many hops) on the network. The routing table can treat, say, the first 4 bits as the network section, and store the same next hop for all addresses starting with those four bits. Of course, this rests on the assumption that all &lt;span class="caps"&gt;IP&lt;/span&gt; addresses starting with those bits are roughly grouped together on the network. This arrangement saves a lot of space in the routing table by combining “redundant” entries. By redundant entries, I mean that, if packets going to 123.121.111.111 and 123.123.123.123 are heading in the same general direction, the router doesn’t need to keep a separate line in the routing table for each of them. Under the old classful system (assuming they were both class B networks), two entries would have been required – one for addresses starting with 123.121 and one for 123.123. As a packet is passed on from hop to hop and gets closer to its destination, routers can treat the network section of the address as being larger in their routing&amp;nbsp;tables.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="subnet-masks-finally"&gt;
&lt;h2&gt;Subnet masks&amp;nbsp;(finally)&lt;/h2&gt;
&lt;p&gt;So, what do subnet masks have to do with all of this? Subnet masks are an implementation detail of the architecture I’ve described above. First, what is a bitmask in the general sense? Bitmasks are a way of allowing a computer to efficiently check whether a portion of one set of bytes matches another set of bytes. Let’s say we have the single byte 1101 1001, and we want to check whether the first four bits are actually 1101. First, we apply the mask 1111 0000 by bitwise ANDing the byte with the mask. We get 1101 0000 as the result. Now, we do a bitwise comparison with the byte 1101 0000, and we’ve verified the first four bits. When using a netmask, the set of input bytes is an &lt;span class="caps"&gt;IP&lt;/span&gt; address. Let’s say we’re a router in the early days of the internet, we’ve received a packet for &lt;span class="caps"&gt;IP&lt;/span&gt; 18.165.1.1, and we want to use our routing table to know where it should go next. We know that we only care about the first byte, so we can apply the mask 11111111 00000000 00000000 00000000 (255.0.0.0) to get 18.0.0.0. Now, looking that up in our routing table, we see the entry matching 18.0.0.0, and we know the next hop for the packet. So, a netmask is just a way of checking that a section of an &lt;span class="caps"&gt;IP&lt;/span&gt; address matches some other &lt;span class="caps"&gt;IP&lt;/span&gt; address that happens to be very efficient for CPUs. A subnet mask is a use of a netmask to check whether a packet is bound for a particular subsection of the network. Of course, I could have just told you that at the beginning, but you wouldn’t have appreciated its significance without a little understanding of why we need to do that sort of checking in&amp;nbsp;practice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="assorted-other-details"&gt;
&lt;h2&gt;Assorted other&amp;nbsp;details&lt;/h2&gt;
&lt;p&gt;What about the alternative notation I mentioned earlier, using /24? This notation is known as &lt;span class="caps"&gt;CIDR&lt;/span&gt; notation. Remember, with &lt;span class="caps"&gt;CIDR&lt;/span&gt;, we can have the network portion of an &lt;span class="caps"&gt;IP&lt;/span&gt; address be any number of bits. Writing out a netmask for some arbitrary number of bits is a little bit awkward in decimal dotted-quad notation. It’s much easier to just specify the length of the mask, aka the number of bits that are part of the network section. So, if we only want to match on the first four bits, we’d use “/4”. When a computer pairs an &lt;span class="caps"&gt;IP&lt;/span&gt; address and a subnet mask together, like 123.123.123.100/24, it’s saying, “from my perspective, this address has 24 bits (123.123.123) corresponding to the subnetwork it is destined for, and 8 bits (“100”) corresponding to the host it is destined for on that subnet. This is exactly the same as specifying a subnet mask of 255.255.255.0 – three bytes of 11111111 and one byte of&amp;nbsp;00000000.&lt;/p&gt;
&lt;p&gt;So far, in this post I’ve only discussed IPv4. It’s important to note that there is a whole other implementation of &lt;span class="caps"&gt;IP&lt;/span&gt;, known as version 6 (IPv6).  Aside from the other challenges I’ve mentioned, there simply aren’t enough IPv4 addresses to go around. Having ~4.3 billion possible addresses seemed like in inexhaustable supply in the early days of the Internet, but that proved to be another false assumption. The most obvious solution to this problem is to increase the number of addresses – IPv6, released in 1993, changes the address format to be 128 bits (16 bytes), which allows for an address space of 2&lt;sup&gt;128&lt;/sup&gt;, more than enough addresses (~3.4 x 10&lt;sup&gt;38&lt;/sup&gt; of them) for the foreseeable future. Unfortunately, updating a protocol without having backwards compatibility is quite a challenge. Plenty of devices connected to the Internet have legacy software that is difficult to patch with IPv6 compatability, making switching completely to IPv6 almost impossible at present. If you tried to only use IPv6, you would not be guaranteed interoperability with the entire Internet. Thus, IPv4 will probably remain the dominant addressing system in the nearer&amp;nbsp;term.&lt;/p&gt;
&lt;p&gt;The main solution to IPv4 address exhaustion has involved creating smaller private subnetworks behind a public router. This is most likely the way that you connect to the Internet at home. If you assign one single public IPv4 address to your router, and have the router create an internal network blocked off from the outside world, you can connect many more devices using the same global 32 bit address space. In this system, the main Internet is referred to as the &lt;span class="caps"&gt;WAN&lt;/span&gt;, or wide area network, and the sub network is known as the &lt;span class="caps"&gt;LAN&lt;/span&gt;, or local area network. Configuring these local networks involves another use of subnet masks. Most home routers have an internal network with an address range that’s something like 192.168.0.0 to 192.168.0.255. Because these addresses aren’t connected to the wider Internet, every router can use this same range without risk of confusion. It’s the router’s job to handle the distribution of incoming packets to the correct device. In the case I describe, the router is using a subnet mask of 255.255.255.0: everything matching 192.168.0 over the first three bytes is destined for some computer on the local network. If you have too many people over for dinner (or working for your company), you might run out of addresses in this range. One thing you could do is change the subnet mask to 255.255.0.0, giving you many more addresses to work&amp;nbsp;with.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="to-summarize"&gt;
&lt;h2&gt;To&amp;nbsp;summarize&lt;/h2&gt;
&lt;p&gt;In conclusion, here are the key takeaways from my original question. First, a bitmask is a way for a computer to efficiently check whether part of a chunk of bytes matches some pattern. Second, a netmask is a bitmask designed to check whether part of a network address matches a specific pattern. Third, subnet masks are a category of netmasks, used to match whether a message is destined for a particular subsection of a network. In practice, the difference between a netmask is almost always nonexistent, as netmasks are usually used as subnet masks. And finally, one (of many) applications of subnet masks is related to the routing of packets on the Internet, a system which has an interesting history behind&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Thanks to Or Mattatia and Ahmad Jarara for their comments and&amp;nbsp;suggestions.&lt;/p&gt;
&lt;/div&gt;
</content><category term="writing"></category></entry><entry><title>Asyncio concepts for beginners</title><link href="https://www.danielputtick.com/writing/asyncio-basics.html" rel="alternate"></link><published>2017-06-26T15:00:00-04:00</published><updated>2017-06-26T15:00:00-04:00</updated><author><name>Dan Puttick</name></author><id>tag:www.danielputtick.com,2017-06-26:/writing/asyncio-basics.html</id><summary type="html">&lt;p&gt;Asyncio is a relatively new standard-library solution for writing concurrent programs in Python. It was initially released with Python 3.4, greatly improved in 3.5, and has a solidified &lt;span class="caps"&gt;API&lt;/span&gt; in 3.6. If you’re not entirely sure what “concurrent” means, you should be aware that there are …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Asyncio is a relatively new standard-library solution for writing concurrent programs in Python. It was initially released with Python 3.4, greatly improved in 3.5, and has a solidified &lt;span class="caps"&gt;API&lt;/span&gt; in 3.6. If you’re not entirely sure what “concurrent” means, you should be aware that there are some subtleties in the terminology surrounding the topic (one great place to learn more is a talk called &lt;a href="https://blog.golang.org/concurrency-is-not-parallelism"&gt;Concurrency is Not Parallelism&lt;/a&gt; by Rob Pike). But, for the sake of this tutorial you can just think of a concurrent program as one that tries to “do many things at once” – a common example might be a web server handling many requests from different users. Asyncio is an important development for Python – the language has arguably been missing support for native concurrency comparable to that in node.js or Go, to name two&amp;nbsp;examples.&lt;/p&gt;
&lt;p&gt;If you’re trying to use asyncio and you find yourself frustrated, you should know that you’re not alone. At present, getting started developing with asyncio is still somewhat difficult. The module contains a confusing array of primitives, as Armin Ronacher &lt;a href="http://lucumr.pocoo.org/2016/10/30/i-dont-understand-asyncio/"&gt;describes&lt;/a&gt;, and the changes that were made between Python 3.4 and 3.5 only add to the confusion. From my perspective, the official documentation is still an unfinished product. Hopefully, it will improve to match the rest of the excellent Python standard library docs now that major changes to asyncio are less likely. There are various tutorials describing things you can build with asyncio, as well as guides to the higher-level concepts behind asyncio-style concurrency. However, if you’re stuck trying to write your first few scripts on your own, this post might help you past that&amp;nbsp;roadblock.&lt;/p&gt;
&lt;p&gt;In an appearance on the &lt;a href="https://talkpython.fm/episodes/show/107/python-concurrency-with-curio"&gt;Talk Python to Me&lt;/a&gt; podcast, David Beazley expressed his frustration that so many explanations of complex libraries like asyncio start with the technical underpinnings of the design and then build up to providing practical information about using the tool. For some people, writing toy examples to play around with is the best way to grow that lower-level understanding. I’ll try to identify what you need to get started writing simple asyncio programs and explain a few details about how the module works. There are also links to the standard library documentation for each&amp;nbsp;section.&lt;/p&gt;
&lt;p&gt;Note that, for the sake of simplicity, everything in this guide assumes you’re using Python 3.5+ (preferably 3.6, it’s great!). If you see things like &lt;code&gt;yield from&lt;/code&gt; or &lt;code&gt;@asyncio.coroutine&lt;/code&gt; elsewhere, the author is probably using Python 3.4. The 3.5+ equivalents are &lt;code&gt;await&lt;/code&gt; and &lt;code&gt;async def&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://docs.python.org/3/library/asyncio-task.html#coroutines"&gt;Coroutines&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When you start writing a program with asyncio, the first thing you’ll want to do is define some coroutines. In asyncio, coroutines serve the same role as functions do in normal, synchronous code – they help break up the problem into smaller pieces. A coroutine looks a lot like a normal Python function, except that you add an &lt;code&gt;async&lt;/code&gt; keyword:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Hello world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The code inside a coroutine can be identical to the code inside a function body – you can assign variables, call synchronous functions, &lt;code&gt;print()&lt;/code&gt; things, etc. You can also do something that you can’t do inside a function: call other coroutines! To call a coroutine from inside another coroutine, you can use the &lt;code&gt;await&lt;/code&gt; keyword, and then invoke the coroutine as you would a&amp;nbsp;function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In this case, the coroutine &lt;code&gt;baz&lt;/code&gt;, defined elsewhere, will be run, and whatever it returns will be assigned to &lt;code&gt;bar&lt;/code&gt;. You can also run &lt;code&gt;baz&lt;/code&gt; without storing its result: &lt;code&gt;await baz()&lt;/code&gt;. Calling a coroutine inside another coroutine is intentionally designed to resemble calling a function. However, don’t forget: you’ll get a &lt;code&gt;SyntaxError&lt;/code&gt; if you use &lt;code&gt;await&lt;/code&gt; in synchronous&amp;nbsp;code.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://docs.python.org/3/library/asyncio-eventloops.html#event-loops"&gt;Event&amp;nbsp;Loops&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After reading that last sentence, you might be wondering: how do you call the ”first“ coroutine before using &lt;code&gt;await&lt;/code&gt; syntax to call the others? There must be a way to call coroutines ”normally“. If you’re the experimenting type, you might try calling a coroutine just like a function: &lt;code&gt;foo()&lt;/code&gt;. You’ll see that nothing seems to occur (although something does happen behind the scenes). Interestingly, when you call a coroutine without &lt;code&gt;await&lt;/code&gt;, you don’t actually start running the code inside the coroutine. Rather, the coroutine initializes itself and then waits for something else to tell it to&amp;nbsp;run.&lt;/p&gt;
&lt;p&gt;So, getting back to our question: how do you run a coroutine when you aren’t already inside of another coroutine? The answer is, you have to manually “schedule” its execution. Remember, we’re trying to write programs that “do many things at once” – in this context, “scheduling” a coroutine means adding it to the set of “things” that we want to run concurrently. In order to manage this set of scheduled coroutines, we have to introduce another important asyncio concept: the event loop. I’ll explain more about what event loops are a little later, but for now you should just think of them as the black box responsible for managing the execution of all coroutines that are running at any point in time. Asyncio has a built-in function that returns the default event&amp;nbsp;loop:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;

&lt;span class="n"&gt;our_loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_event_loop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;a href="https://docs.python.org/3/library/asyncio-task.html#task"&gt;Tasks&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that we have our event loop, we need to tell it to schedule and run a coroutine. To do that, we’ll only need a few lines of code. First, as discussed above, we initialize our&amp;nbsp;coroutine:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;our_task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;our_coroutine&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I’ve named the variable &lt;code&gt;our_task&lt;/code&gt;, because &lt;code&gt;Task&lt;/code&gt; is what asyncio calls an initialized coroutine. Task objects have some useful methods, but we don’t need to worry about them for now. Understanding exactly what &lt;code&gt;Tasks&lt;/code&gt; are (and &lt;code&gt;Futures&lt;/code&gt;, of which &lt;code&gt;Tasks&lt;/code&gt; are a subclass) isn’t critical for writing simple asyncio programs. Then, we tell our event loop (which we created earlier) to run our&amp;nbsp;task:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;our_loop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_until_complete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;our_task&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And that’s it! The event loop will manage the execution of our coroutine until it returns. Whatever &lt;code&gt;our_task&lt;/code&gt; returns will also be returned by &lt;code&gt;run_until_complete&lt;/code&gt;. As a side note, when we use &lt;code&gt;await&lt;/code&gt; syntax to call a coroutine, that coroutine is also being scheduled by the event loop. In that case, asyncio handles the scheduling automatically, instead of having us do it ourselves. So, if &lt;code&gt;our_coroutine()&lt;/code&gt; is awaiting other coroutines, the event loop is scheduling those as&amp;nbsp;well.&lt;/p&gt;
&lt;h2&gt;&lt;a href="https://docs.python.org/3/library/asyncio-task.html#task-functions"&gt;Task&amp;nbsp;Functions&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With just these tools, you can start writing some toy programs to get a better feel for using asyncio. However, chances are you’ll often want to start many coroutines at the same time, and wait for all of them to complete before proceeding. Asyncio offers a few built-in ways to &lt;code&gt;await&lt;/code&gt; many coroutines at the same time using just one line of code. The two most immediately useful ones are &lt;code&gt;asyncio.gather()&lt;/code&gt; and &lt;code&gt;asyncio.wait()&lt;/code&gt;. The difference between them is somewhat subtle. &lt;code&gt;asyncio.gather()&lt;/code&gt; takes a sequence of tasks (aka initialized coroutines) passed in directly as a &lt;code&gt;*arg&lt;/code&gt;. If you have, say, a list of tasks, using &lt;code&gt;asyncio.gather()&lt;/code&gt; looks&amp;nbsp;like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# you will have written and initialized these tasks earlier, as above&lt;/span&gt;
&lt;span class="n"&gt;list_of_tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;list_of_tasks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;On the other hand, asyncio.wait() takes the entire sequence as its&amp;nbsp;argument:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;tuple_of_tasks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;task3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# could be a list, dict keys, etc&lt;/span&gt;
&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pending&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tuple_of_tasks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Along with the syntax, there is a functional difference between &lt;code&gt;gather&lt;/code&gt; and &lt;code&gt;wait&lt;/code&gt;. With &lt;code&gt;gather&lt;/code&gt;, you have no control over the coroutines that are being executed. You can’t cancel them or make them time out. With &lt;code&gt;wait&lt;/code&gt;, you can interact with specific tasks and cancel them. You can also control the conditions under which &lt;code&gt;wait&lt;/code&gt; returns – for example, you can have it return immediately when any one of the coroutines you passed in finishes, rather than waiting for all of them. You can read &lt;a href="https://docs.python.org/3/library/asyncio-task.html#task-functions"&gt;this&lt;/a&gt; section of the documentation for more details. There are a few more useful task functions listed there as well: take a look at &lt;code&gt;as_completed&lt;/code&gt; and &lt;code&gt;sleep&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;More on event&amp;nbsp;loops&lt;/h2&gt;
&lt;p&gt;As I mentioned earlier, event loops are the “black boxes” that run multiple coroutines simultaneously. Event loops are designed to deal with the problem of how to &amp;#8220;do many things at once&amp;#8221; when you can only perform a single computation with each &lt;span class="caps"&gt;CPU&lt;/span&gt; cycle. As an illustrative analogy, let’s say you’ve sent a message to ten different friends and you’re waiting for them to respond. When you do receive a response, you’ll then take the time to read it. However, let’s pretend that you can only check for a response from one friend at a time, rather than all of them at once. Your solution would likely be to look for a new message from each friend in sequence, and then repeat this process from the top of the list. This is more or less what an event loop does! Event loops are used throughout your computer when something needs to monitor and wait for a “message” of some sort. For example, something resembling an event loop is used by your &lt;span class="caps"&gt;USB&lt;/span&gt; driver to register input from a &lt;span class="caps"&gt;USB&lt;/span&gt; keyboard. Some code for a very simple event loop might&amp;nbsp;be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;coroutine&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;coroutines&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;coroutine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_computation_to_run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;coroutine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In fact, the asyncio event loop implementation contains something like this &lt;code&gt;while&lt;/code&gt; loop, albeit surrounded by a lot of other code designed to make it more efficient. You can see it in the CPython source code, here: https://github.com/python/cpython/blob/3.6/Lib/asyncio/base_events.py#L420-L423. Modern event loops don’t run continuously, but rather use events called “interrupts” to pause and resume their execution. This makes sense, because having a constantly running loop is an inefficient use of &lt;span class="caps"&gt;CPU&lt;/span&gt; cycles, especially when you don’t expect events to occur particularly frequently. If, in the above example, you’re expecting a new message from your friends every 2 hours or so, cycling through your messaging app constantly is probably not the best use of your time. Further details about event loop implementations are interesting, but outside the scope of this&amp;nbsp;post.&lt;/p&gt;
&lt;p&gt;Asyncio comes with its own default implementation of an event loop, but using it isn’t essential to the functioning of asyncio. If you’d like, you can switch out the default event loop for a third-party event loop implementation. One such external event loop module that’s getting a lot of attention is &lt;a href="https://magic.io/blog/uvloop-blazing-fast-python-networking/"&gt;uvloop&lt;/a&gt;. Switching to another event loop is as simple as installing it with pip, importing it, and selecting&amp;nbsp;it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;uvloop&lt;/span&gt;

&lt;span class="n"&gt;loop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;uvloop&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new_event_loop&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_event_loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;loop&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Of course, the default event loop is fine for most purposes that aren’t overly concerned about performance – it’s just worth noting that it’s a piece of code like anything else and isn’t somehow magically baked into&amp;nbsp;asyncio.&lt;/p&gt;
&lt;h2&gt;Final&amp;nbsp;thoughts&lt;/h2&gt;
&lt;p&gt;One potential point of confusion when using asyncio revolves around the difference between “blocking” and “non-blocking” code. You’re familiar with the concept of blocking even if you don’t realize it yet – all synchronous code is blocking when run on the Python interpreter. Blocking code is code that prevents the program from continuing until it has finished executing. When you write normal Python, you can rely on the interpreter to execute the code in the order you wrote it because each instruction “blocks” until it finishes. As I mentioned above, you can run any synchronous code from inside an asynchronous coroutine. However, if any of your synchronous code has the potential to pause and not complete, it can bring the execution of your entire program to a halt. This is why, for example, you shouldn’t use the popular &lt;a href="http://docs.python-requests.org/en/master/"&gt;Requests&lt;/a&gt; library to make http requests inside a coroutine. Instead, you should use a library like &lt;a href="https://aiohttp.readthedocs.io/en/stable/"&gt;Aiohttp&lt;/a&gt;, which implements non-blocking http requests using asyncio coroutines. On the other hand, even though something like &lt;code&gt;print()&lt;/code&gt; is technically blocking, it’s safe to use because its behavior and execution time is&amp;nbsp;predictable.&lt;/p&gt;
&lt;p&gt;When I first started trying out asyncio, I found it frustrating and hard to use. I wanted to write something like the concurrent version of “hello world”, whatever that may be, but it wasn’t obvious how to do so. With just the information from this tutorial, I hope you’ll be able to write a simple program that, say, runs a bunch of coroutines which each count up to 10 concurrently. &lt;a href="https://gist.github.com/dputtick/c76039b11f86b1a58c458321a5bbac20"&gt;Here’s a gist&lt;/a&gt; with an example in case you’d like some inspiration. Since so many applications of concurrency involve programming for the web, you might want to try something like writing a small web crawler once you’ve got the hang of basic asyncio concepts. Best of&amp;nbsp;luck!&lt;/p&gt;
&lt;p&gt;Thanks to Julia Evans, Laura Lindzey, and Emil Sit for their comments and&amp;nbsp;suggestions.&lt;/p&gt;</content><category term="writing"></category></entry><entry><title>Naming things</title><link href="https://www.danielputtick.com/writing/naming-things.html" rel="alternate"></link><published>2017-06-01T14:00:00-04:00</published><updated>2017-06-02T14:00:00-04:00</updated><author><name>Dan Puttick</name></author><id>tag:www.danielputtick.com,2017-06-01:/writing/naming-things.html</id><summary type="html">&lt;p&gt;Naming things  – choosing a string of characters to represent a given expression – can be frustrating and difficult. This might be obvious, but the abstraction of referring to a block of code with something memorable and human readable greatly increases the ease of programming. Whoever first realized that we could use …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Naming things  – choosing a string of characters to represent a given expression – can be frustrating and difficult. This might be obvious, but the abstraction of referring to a block of code with something memorable and human readable greatly increases the ease of programming. Whoever first realized that we could use memorable words like &lt;span class="caps"&gt;MOV&lt;/span&gt; and &lt;span class="caps"&gt;GOTO&lt;/span&gt; instead of numeric opcodes was responsible for a huge advance in programming language design. In a sense, every time we abstract away a function, script, module, or program using a name, we’re building on that simple idea. Being able to reference other parts of a program is important in its own right, but it isn’t nearly as effective if you have to refer to your function by say, its location in memory, rather than a name that describes what it does. However, when we choose names to take advantage of this abstraction superpower, there’s an inherent conflict between brevity and being descriptive. Deciding how to name things has been referred to as one of the hardest problems in programming&lt;sup id="fnref:fn-1"&gt;&lt;a class="footnote-ref" href="#fn:fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;. I’ve been thinking about how to do a better job at this lately, and here are some notes I’ve made on the topic. Some of them might seem sort of contradictory – I think that’s just an indication of how naming things is complex and&amp;nbsp;nuanced.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Good design makes it easier to name things. Dividing your code up into modular parts is an important part of writing clean, maintainable software. If the name of a component isn’t at least somewhat intuitive based on what it does, it’s possible that you’ve chosen to break up your problem in a less than optimal way. Also, once you have descriptively named and well documented components that have a clear interface and that only do one thing, the problem of naming things used inside the scope of that component becomes&amp;nbsp;easier.&lt;/li&gt;
&lt;li&gt;Consider potential sources of ambiguity, especially from the perspective of somebody who isn’t familiar with the overall structure of the project. In &lt;a href="https://github.com/CIRCL/PyCIRCLean"&gt;PyCIRCLean&lt;/a&gt;, there are times when we have a single method containing separate references to each of: a string representing a path to a file, a Python file object, and a class containing information about a file. If we had static types or type hints, the reader would receive extra information to help understand what each variable refers to. Given that we don’t have type information, we decided on names like “file_path”, “opened_file”, and “file_object”. Always considering your reader’s perspective aligns with good programming practices in general (and is a principle of writing good prose,&amp;nbsp;too).&lt;/li&gt;
&lt;li&gt;Sometimes the right name won’t occur to you right away. It’s ok and worthwhile to wait for the perfect name if one isn’t immediately obvious, rather than forcing a name that isn’t great. But, you also don’t want to get stuck spending an hour optimizing one name. An adequate solution is to just use whatever name you come up with and then come back when you’ve had time to think of something better. However, take care – suboptimal names can proliferate and become more difficult to change with&amp;nbsp;time.&lt;/li&gt;
&lt;li&gt;Generally speaking, the greater the infrequency or “distance” between usages of a component, the longer and more descriptive its name should be. Names that are used infrequently and far apart won’t easily stick in the reader’s memory, and they’ll have to frequently consult the documentation or the location in the program where the name is defined. A more descriptive name will help smooth the process of understanding what the code does. On the other end of the spectrum are examples like the convention of using &lt;code&gt;i&lt;/code&gt; to count the current loop number or index into an array/list. Somebody reading the code can see the entire context for the variable’s usage inside one screen height of their text editor, so they don’t have to keep any extra information in their head. Thus, a short and un-descriptive name is&amp;nbsp;sufficient.&lt;/li&gt;
&lt;li&gt;Be especially careful with global variables, public attributes, or names that are referenced often throughout a program. If something is referenced many times, future programmers (including yourself) will be more reluctant to change it. Also, if you’re going to be exposing an &lt;span class="caps"&gt;API&lt;/span&gt;, your users will not be happy if you make breaking changes. Do the best that you can the first time, and don’t be afraid to take a little extra time to make the decision. As a side note, a variable appearing in many different locations &lt;em&gt;can&lt;/em&gt; be an indication that you should consider reorganizing your code. Sometimes, you do need global variables, but having naming issues with a global variable is a code smell that you should at least think carefully&amp;nbsp;about.&lt;/li&gt;
&lt;li&gt;One thing that sometimes comes up in discussions of  variable naming is &lt;a href="https://en.wikipedia.org/wiki/Hungarian_notation"&gt;Hungarian notation&lt;/a&gt;: the practice of including meta-information about a component in its name. This can include information about a broader category that the component belongs to, or its actual data type. Although many discussions of variable name argue against Hungarian notation, I’d encourage you to read &lt;a href="https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/"&gt;Making Wrong Code Look Wrong&lt;/a&gt; by Joel Spolsky. Essentially, his argument is that Hungarian notation as it was originally conceived of provides a useful way of, well, making wrong code look&amp;nbsp;wrong.&lt;/li&gt;
&lt;li&gt;Follow conventions set elsewhere in the codebase. Let’s say you start working on a large Python project for the first time. You’ve previously read that, in Python, variable names are normally lowercase_with_underscores, and every other project you’ve seen has followed that convention. In your new project, however, you see that variable names are in camelCase. What should you do? First, whatever you do, you’ll want to maintain uniformity throughout the codebase – the worst option is to start using lowercase variables in your contributions and not tell anyone. This is because projects that don’t have uniform style are generally harder to read. Depending on how large the codebase is, you could spend some time making everything Pythonic. In the worst case scenario, this could take a few weeks, potentially break things, and annoy your coworkers with the massive diff you will generate. In that case, the best course of action is to imitate the style of the rest of the project, regardless of what it&amp;nbsp;is.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:fn-1"&gt;
&lt;p&gt;&lt;a href="https://martinfowler.com/bliki/TwoHardThings.html"&gt;https://martinfowler.com/bliki/TwoHardThings.html&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:fn-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="writing"></category></entry><entry><title>On pair programming</title><link href="https://www.danielputtick.com/writing/pairing.html" rel="alternate"></link><published>2017-05-24T16:00:00-04:00</published><updated>2017-05-24T16:00:00-04:00</updated><author><name>Dan Puttick</name></author><id>tag:www.danielputtick.com,2017-05-24:/writing/pairing.html</id><summary type="html">&lt;p&gt;As I described at length in my &lt;a href="https://www.danielputtick.com/journal/return-statement.html"&gt;Return Statement&lt;/a&gt;, I spent part of summer 2016 at the &lt;a href="https://www.recurse.com/"&gt;Recurse Center&lt;/a&gt;. In that piece, I mentioned pair programming as an important part of the &lt;span class="caps"&gt;RC&lt;/span&gt; experience. Being in an environment that encourages and facilitates it was a great opportunity. I paired for …&lt;/p&gt;</summary><content type="html">&lt;p&gt;As I described at length in my &lt;a href="https://www.danielputtick.com/journal/return-statement.html"&gt;Return Statement&lt;/a&gt;, I spent part of summer 2016 at the &lt;a href="https://www.recurse.com/"&gt;Recurse Center&lt;/a&gt;. In that piece, I mentioned pair programming as an important part of the &lt;span class="caps"&gt;RC&lt;/span&gt; experience. Being in an environment that encourages and facilitates it was a great opportunity. I paired for the first time at &lt;span class="caps"&gt;RC&lt;/span&gt;, but I felt that I didn’t pair as much as I could have. Anecdotally, it seems that many &lt;span class="caps"&gt;RC&lt;/span&gt; alumni also wish they had paired more during their batch. To help understand why pairing is worthwhile and why it can be difficult to do more of it, I decided to explore the topic in detail. In this piece, I’ll address two questions. First, what are the benefits and drawbacks of pair programming? And second, what are some concrete suggestions to make pairing sessions more&amp;nbsp;successful?&lt;/p&gt;
&lt;p&gt;In preparation, I read various blog posts and academic papers, tried a few pairing experiments myself, and talked with programmers I know about their pairing experiences. I’ll do my best here to summarize the conclusions I drew. First of all, I’d like to note that, in my opinion, there’s an important distinction between pairing full-time at work and pairing part-time and/or outside of work. Pairing full-time needs to be sustainable over periods of weeks or months, and different challenges arise when spending such a large amount of time working so closely with others. In addition, the goals of pairing sessions are different depending on the context. When pairing full-time, the main concern is having overall productivity and code-quality equal to or exceeding what is possible when working individually. With part-time pairing, the aim is to solve a specific problem or learn something&amp;nbsp;new.&lt;/p&gt;
&lt;p&gt;There isn’t a universal definition of pair programming, but it might be helpful to briefly identify what makes it different from ordinary collaboration. Perhaps this is obvious, but a key aspect of pairing is sharing one screen between two people. Talking with somebody about your code or sitting next to them and working on the same project separately doesn’t count as pairing. Most definitions of pairing mention an explicit division of labor between the “navigator” and the “driver”, with those roles usually trading off frequently. The driver is responsible for inputting text, while the navigator helps talk through problems, watches for mistakes, makes suggestions, and looks up reference material. This avoids the chaos of two people trying to type at the same&amp;nbsp;time.&lt;/p&gt;
&lt;h3&gt;Technical aspects of pair&amp;nbsp;programming&lt;/h3&gt;
&lt;p&gt;When looking at the benefits of pair programming, opinions seem fairly unanimous that it tends to increase code quality. One way it does this is by causing a dramatic decrease in the frequency of simple mistakes and small bugs. Avoiding small errors is hugely valuable, as anyone who has spent 8 hours debugging the results of a random typo can attest. Depending on your opinion about how costly these bugs are overall, this alone might be enough to justify pairing frequently or full-time. You could argue that linters and proper tooling can catch most mistakes of this category, but there are certain things that linters will miss. For example, if you have a typo that references a variable name that hasn’t been defined, a linter will identify the mistake, but if you accidentally refer to a different variable from the one you intended, the linter won’t give you an&amp;nbsp;error.&lt;/p&gt;
&lt;p&gt;From a bigger-picture point of view, you can also think of pairing as a type of constant ongoing code review. Having another person to discuss design questions with during the process of programming should certainly contribute to improving the quality of architectural decisions. However, one thing pairing doesn’t exactly provide for is time to think deeply. If you don’t explicitly make space for it, the fact that you’re talking and typing constantly while pairing doesn’t leave much time to think. If one person is convinced that they have the right solution, but the other has the feeling that there is more to consider, it can be difficult to say “wait, we need to take a break to think this over.” If there are differences between the pair in bias to action or active versus reflective learning styles&lt;sup id="fnref:fn-1"&gt;&lt;a class="footnote-ref" href="#fn:fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;, one person’s ideas might be undervalued. If the best solution to a problem is not the most obvious one, pairing could make you more likely to miss it. I’ll talk more about how you can structure pairing to prevent these sorts of outcomes&amp;nbsp;later.&lt;/p&gt;
&lt;h3&gt;Human&amp;nbsp;factors&lt;/h3&gt;
&lt;p&gt;Many of the sources I read reported human-related factors as a major component of whether or not pairing is successful. The need for high levels of focus and constant attention mean that pair programming can be exhausting. If you’re more introverted, or if having somebody else look at your code causes anxiety, you’ll likely feel even more tired. If you’re pairing in the workplace full-time it will probably take a while to become fully acclimated and avoid ending every day with your energy levels depleted. One thing that helps is taking regularly scheduled breaks. I think pair programming integrates particularly well with the &lt;a href="https://en.wikipedia.org/wiki/Pomodoro_Technique"&gt;Pomodoro Method&lt;/a&gt; for this reason. In fact, this is a positive aspect of pairing: if properly organized and planned, it can help programmers maintain their energy levels and (hopefully) be more effective as a result. Having two people for accountability is more effective than relying on your own&amp;nbsp;self-discipline.&lt;/p&gt;
&lt;p&gt;One benefit of pairing that was mentioned repeatedly is that pairing is an actively &lt;em&gt;fun&lt;/em&gt; experience. If you have a personality type that draws energy from collaborative activities, pairing is a way to satisfy that need with a pursuit that otherwise takes place in solitude. But, as I mentioned above, if you’re on the introverted side of the introvert-extrovert scale, pairing can be more stressful than pleasant. Even if you do find find working with others enjoyable, perhaps this is outweighed by the anxiety of exposing your thought process or self-perceived skill level to somebody else. For some people, programming alone is preferable, and this doesn’t make you less of a programmer or mean that something is wrong with you. In fact, it might even be useful to consider pairing a related but entirely different activity than programming alone. At least, from my personal experience, the subjective &lt;em&gt;feeling&lt;/em&gt; of pair programming is different, much the same way that team activities or sports differ from things like running or painting on your&amp;nbsp;own.&lt;/p&gt;
&lt;p&gt;Another frequently mentioned benefit of pairing was the value of the constant exchange of information between pairing partners. In my opinion, one of the most fulfilling aspects of programming is learning from and teaching others. Additionally, sharing knowledge is a great way to clarify and solidify concepts in your mind. Multiple resources mentioned that knowledge transfer was particularly effective in cases with a gap in domain-specific knowledge. For example, an expert in a specific programming language can teach somebody else with a strong grasp of generalized programming concepts a large amount in a short period of time. A team with diverse backgrounds that encourages pairing probably distributes knowledge rapidly between its various members, which likely results in a high rate of individual growth as programmers. In today’s hiring market, where so many companies claim to be struggling to find more experienced programmers, pairing seems like a secret weapon to combine with the alternative strategy of hiring less experienced candidates and teaching them what they need to&amp;nbsp;know.&lt;/p&gt;
&lt;p&gt;Every programmer knows that programming can be extremely difficult and frustrating. This can inevitably lead to procrastination, regardless of how much discipline you have. Pairing is a great way to help cope with this problem, because it gives you a partner in helping to stay on task. Several of the blog posts I read reported that pairing decreased the amount of time they spent repeatedly checking email and doing other menial tasks. This is great for everybody: programmers are more productive, and they can spend less time working to achieve the same results. To me, 6 to 8 hours of highly focused work is much better than 10 hours littered with distractions and suboptimal use of&amp;nbsp;time.&lt;/p&gt;
&lt;h3&gt;Suggestions for better pairing&amp;nbsp;sessions&lt;/h3&gt;
&lt;p&gt;As I’ve discussed, there are both benefits and drawbacks that come with pair programming. Some of these are inherent; for example, if you have strong introvert tendencies pairing will probably be more difficult for you. However, there are specific ways to structure pairing that can result in higher levels of enjoyment and productivity. I’ve already mentioned one: taking frequent breaks to avoid burnout. Another solution to burnout is to rotate pairing partners frequently. After all, many of us have experienced that spending too much time with the same person can be exhausting. This is also a solution to not having enough time to think deeply while pairing. A 30 minute break to read reference material and think about the problem individually before regrouping can pay great dividends in that&amp;nbsp;regard.&lt;/p&gt;
&lt;p&gt;When pairing, try to have clear expectations and goals for each session. Of course, it’s fine to ask somebody to pair with you and figure it out as you go – spontaneity can be worth preserving. However, it’s definitely worth it to take a moment and say, “this is what we want to accomplish, this is how long we’re going to work before taking a break, and this is what we’ll do if we get stuck.” If one person thinks the goal of a pairing session is to fix a specific bug, and the other thinks that the goal is to learn more about a general topic, the session is less likely to be successful. The importance of communication lasts during the pairing session as well; if things aren’t working, it’s important to speak up and try to change something. One sometimes underrated aspect of good communication is generally just being kind and respectful. Facilitating an environment where everybody can speak up if they don’t understand something is also important&lt;sup id="fnref:fn-2"&gt;&lt;a class="footnote-ref" href="#fn:fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;, especially when there are potentially large knowledge and experience&amp;nbsp;asymmetries.&lt;/p&gt;
&lt;p&gt;It’s easy for the more experienced programmer to dominate a pairing session, especially when the difference in experience is large. In that situation, it helps to let the less experienced person drive. It might result in things moving slower, but it will ensure that they aren’t being left behind. One surprisingly frustrating aspect of this arrangement can be that newer programmers are often slower at inputting text and using the keyboard efficiently. There isn’t an easy solution, but the more experienced person can take the opportunity to teach a few keyboard shortcuts. Another particularly tricky part of pairing occurs when each person has a different idea of how to solve a problem. At that moment, being willing to try the other person’s solution first regardless of who you think is right can really improve the experience for both of&amp;nbsp;you.&lt;/p&gt;
&lt;p&gt;Another important aspect of pairing successfully is making sure to use the right tools. If you have access to an external monitor, the extra screen space and visibility makes a big difference. I experimented with pairing using two keyboards and found it interesting and useful, although it did make it easier for the navigator to take over from the driver, so some level of structure and communication was required to avoid frequently “interrupting” each other. One surprisingly large barrier to effective pairing is differences in text editor preferences and configuration. It won’t be easy to switch between driver and navigator roles if you have to reopen the document in a different editor or switch to using a different shell each time. From a more philosophical point of view, this seems to me to be an argument against “excessive” customization or using niche tools. I might be wrong though – Vim and Sublime are both widely used, and yet fairly incompatible. I’m not sure there’s a great solution to this, other than perhaps making an effort to be familiar with multiple different text editors, or prioritizing pairing with people who use the same text editor as&amp;nbsp;you.&lt;/p&gt;
&lt;h3&gt;Other&amp;nbsp;thoughts&lt;/h3&gt;
&lt;p&gt;If you’re interested in pairing more but don’t have something like the Recurse Center to facilitate it, there are several possibilities. The first is to try pairing more at work! It might take some extra effort to better structure your environment for pairing (perhaps involving some of the above suggestions), but otherwise, you just need one other interested coworker to get started. If you don’t currently work as a programmer, you can pair with a friend or find a pairing partner at a meetup. Pairing doesn’t necessarily involve working on a massive project or something with real-world applications. Just pick a problem from a site like Project Euler or Hackerrank and see how far you can get in an hour. In fact, these smaller problems are a great way to start, because it’s a small commitment if things don’t go as well as you’d&amp;nbsp;hoped.&lt;/p&gt;
&lt;p&gt;There are some interesting questions to ask about pairing from the perspective of a team lead or manager. From a company’s point of view, the concerns about pair programming seem twofold. First, will the potential increase in code quality and employee happiness be worth the tradeoffs? As an extreme example, for a startup with 4 programmers, switching from 4 to 2 ongoing “lines of development” by pair programming full-time sounds pretty scary. It seems like it’s still probably worth it if your team will be more productive overall, but it’s certainly a valid question. Second, what will you do about the otherwise excellent developers, either current or prospective employees, who aren’t comfortable with pairing? Fortunately, I think that pairing doesn’t require a large initial commitment. You can start by making a small investment in arranging your space to make it easy to pull up a chair and join a coworker at their desk, and then see if you have any team members who’d like to take advantage of&amp;nbsp;it.&lt;/p&gt;
&lt;p&gt;Another exciting development is the elimination of physical proximity as a constraint for pairing. There are numerous tools emerging for pair programming remotely. The simplest option is to just use the screen sharing feature in Skype/Hangouts etc. This doesn’t allow for easy switching between navigator and driver, but for a casual pairing session, that might be fine. There are also more specialized tools, such as Screenhero, Floobits, or tmate, which allow both people to type in a shared text editor. I haven’t tried any of this category yet – maybe I’ll write a post in the future reviewing some of them, but I wanted to be sure to mention this as something worth&amp;nbsp;exploring.&lt;/p&gt;
&lt;p&gt;It can be difficult to get started pair programming, but it’s a great way to grow as a programmer and to write better code. I hope that reading this has inspired you to consider pairing more, and that there were some useful suggestions that might make pairing work better for&amp;nbsp;you.&lt;/p&gt;
&lt;p&gt;The sources I&amp;nbsp;used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.pivotal.io/labs/labs/pair-programming-considered-extremely-beneficial"&gt;Pairing at&amp;nbsp;Pivotal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mwilden.blogspot.com/2009/11/why-i-dont-like-pair-programming-and.html"&gt;Why I don’t like pair&amp;nbsp;programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sarahmei.com/blog/2010/04/14/thoughts-on-two-months-of-pairing/"&gt;Thoughts on two months of&amp;nbsp;pairing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jvns.ca/blog/2014/08/05/pair-programming-is-amazing-except-when-its-not/"&gt;Pair programming is amazing (except when it’s&amp;nbsp;not)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.pivotal.io/labs/labs/pairing-isn-t-for-everyone"&gt;Pairing isn’t for&amp;nbsp;everyone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jvns.ca/blog/2014/03/01/pair-programming/"&gt;Pair&amp;nbsp;programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.recurse.com/manual#sec-pairing"&gt;Recurse center users manual/pairing&amp;nbsp;section&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dev.to/raulavila/my-experience-with-pair-programming"&gt;My experience with pair&amp;nbsp;programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.utexas.edu/users/mckinley/305j/pair-hcs-2006.pdf"&gt;Pair programming&amp;nbsp;productivity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF"&gt;The costs and benefits of pair&amp;nbsp;programming&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://johannesbrodwall.com/2011/02/02/pair-programming-research-misses-the-most-important-point/"&gt;Pair programming research misses the most important&amp;nbsp;point&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.utah.edu/~lwilliam/Papers/ieeeSoftware.PDF"&gt;Strengthening the case for pair&amp;nbsp;programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks to Laura Lindzey, Julia Evans, Khalid Omar Ali, and SengMing Tan for their advice and suggestions. Also to Rose Ames for doing a few pairing-related experiments with&amp;nbsp;me.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:fn-1"&gt;
&lt;p&gt;&lt;a href="http://blog.melchua.com/2014/08/12/learning-styles-for-programmers-activereflective/"&gt;http://blog.melchua.com/2014/08/12/learning-styles-for-programmers-activereflective/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:fn-1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:fn-2"&gt;
&lt;p&gt;&lt;a href="https://jvns.ca/blog/2017/04/27/no-feigning-surprise/"&gt;https://jvns.ca/blog/2017/04/27/no-feigning-surprise/&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:fn-2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="writing"></category></entry></feed>